---
title: "Public Internet Correlation between Population Density or Schools"
subtitle: "DSAN 6750 / PPOL 6805: GIS for Spatial Data Science"
authors:
  - name: Gabriel Soto
    email: gas102@georgetown.edu
    affiliation: Georgetown University
    corresponding: true
format:
  html:
    theme: cosmo
    code-fold: true
    code-tools: false
    code-overflow: wrap
    #toc: true
    #toc-depth: 3
    #toc-location: left
    #number-sections: true
    #html-math-method: katex
    #css: styles.css
    df-print: kable
  pdf:
    # https://quarto.org/docs/reference/formats/pdf.html
    link-citations: true
execute:
  echo: false
  warning: false
  message: false
prefer-html: true
bibliography: GIS_Manuscript.bib
title-block-banner: "#E69F0095"
title-block-banner-color: "black"
---
## Introduction

Do public schools get better access to public internet? This research analyses whether public schools in Panama, get access to public internet via access points
- Google Satellite
- Migration Panama

- meter data temporal de uso de datos por access points
- agregar datos de cantidad de estudiantes por distrito
https://www.inec.gob.pa/archivos/P030194820231213142523Cuadro%2021.pdf
- agregar un indice normalizado (ya que el numero es muy chiquito) de la cantidad de casas sin internet
https://www.inec.gob.pa/archivos/P0705547520240202111515Cuadro%201.pdf

Future:
- indicadores socioeconomicos a nivel de distrito https://www.inec.gob.pa/archivos/P0579518620240202083001Cuadro%204.pdf


dijo:

> It's the remoteness of Oyala that makes it so appealing to President Obiang. In a rare interview he described how rebels had recently plotted a seaborne assault on his palace in the current capital, Malabo. 'We need a secure place for my government and for future governments. That's why we have created Oyala, to guarantee the government of Equatorial Guinea.' [@sackur_equatorial_2012]

This case is far from exceptional, as an even more recent *Washington Post* article points out with respect to Myanmar's decision to move its capital from Yangon to Naypyidaw:

> Analysts have described the decision as motivated by a desire to secure the military’s seat of power from any threat of protests or invasions. [@berger_myanmars_2021]

Most of these studies, however, are based on observations of **conflict events**. In this study, we study the more fundamental variable of a capital's distance from the **population centroid** of the country.

## Literature Review

@campante_capital_2019 analyzes the relationship between the location of a **capital city** and the degree of conflict and misgovernance in a given country. Their two key findings are that:

> Conflict is more likely to emerge (and dislodge incumbents) closer to the capital

and

> Isolated capitals are associated with misgovernance.

This first finding is illustrated in @fig-conflict-dist

```{r import-packages, echo=FALSE}
#library
library(sf)|> suppressPackageStartupMessages()
library(dplyr)|> suppressPackageStartupMessages()
library(stringr)|> suppressPackageStartupMessages()
library(ggplot2)|> suppressPackageStartupMessages()
library(tmap)|> suppressPackageStartupMessages()
library(readr)|> suppressPackageStartupMessages()
library(DT)|> suppressPackageStartupMessages()
library(skimr)|> suppressPackageStartupMessages()
library(plotly)|> suppressPackageStartupMessages()
library(leaflet)|> suppressPackageStartupMessages()
library(plotly)|> suppressPackageStartupMessages()
library(osmdata)|> suppressPackageStartupMessages()
library(spdep)|> suppressPackageStartupMessages()
library(spatstat)|> suppressPackageStartupMessages()

```

```{r main-functions}
#functions
convert_dms_to_decimal <- function(dms_str) {
  # Extract components
  parts <- str_match(dms_str, "(\\d+)° (\\d+)' (\\d+\\.?\\d*)\"\" ([N|S|E|W])")
  
  # Convert components to numeric
  degrees <- as.numeric(parts[, 2])
  minutes <- as.numeric(parts[, 3])
  seconds <- as.numeric(parts[, 4])
  
  # Calculate decimal degrees
  decimal <- degrees + minutes/60 + seconds/3600
  
  # Apply sign based on direction
  direction <- parts[, 5]
  decimal <- ifelse(direction %in% c("S", "W"), -decimal, decimal)
  
  return(decimal)
}

```

```{r data-import, echo=FALSE}

#schools data
schools_csv <- read.csv("data-spatial/schools-data.csv")

#district data
district_path <- "data-spatial/panama-districts/gadm41_PAN_2.json"
# Read GeoJSON data
district_data <- st_read(district_path, quiet = TRUE)
# Fix any invalid geometries
district_data <- st_make_valid(district_data)

#Panama highway
# Read GeoJSON data
highway_data <- st_read("data-spatial/panam-highway.geojson", quiet = TRUE)

#access points data
ap_csv <- read.csv("data-spatial/access-points.csv", fileEncoding="latin1")
ap_data <- st_as_sf(ap_csv, 
                      coords = c("long", "lat"),
                      crs = 4326)
```

```{r cleaning-coordinates-schools, echo=FALSE}
#Cleaning data

# Convert your coordinates
schools_csv$decimal_lat <- convert_dms_to_decimal(schools_csv$lat)
schools_csv$decimal_long <- convert_dms_to_decimal(schools_csv$long)

#removing long, lat columns and creating schools_df
schools_df <- schools_csv %>% select(-lat) %>% select(-long)

# Create SF object with converted coordinates from schools_df
schools_data <- st_as_sf(schools_df, 
                      coords = c("decimal_long", "decimal_lat"),
                      crs = 4326)
```

```{r removing-objects, echo=FALSE}
rm(schools_csv, district_path, ap_csv, schools_df)
```
## Exploratory Data Analysis (EDA)

Below we display two tables for both ** Districts and at the Province level ** showing relevant indicators such as:
- Numbers of schools
- Numbers of Access Points
- Population
- Access Points per School Ratio
- Access Points per 1000 people Ratio
```{r exploratoy-data-analysis, echo=FALSE}

#province summary
province_summary <- schools_data %>%
  st_drop_geometry() %>%
  group_by(province) %>%
  summarise(schools = n()) %>%
  full_join(
    ap_data %>%
      st_drop_geometry() %>%
      group_by(province) %>%
      summarise(access_points = n()),
    by = "province"
  ) %>%
  full_join(
    district_data %>%
      st_drop_geometry() %>%
      group_by(NAME_1) %>%
      summarise(population = sum(population)),
    by = c("province" = "NAME_1")
  ) %>%
  mutate(
    ap_per_school = round(access_points/schools, 2),
    ap_per_1000_people = round((access_points/population) * 1000, 2)
  )


#district summary
district_summary <- schools_data %>%
  st_drop_geometry() %>%  # Remove spatial component
  group_by(district) %>%
  summarise(schools = n()) %>%
  full_join(
    ap_data %>%
      st_drop_geometry() %>%  # Remove spatial component
      group_by(district) %>%
      summarise(access_points = n()),
    by = "district"
  ) %>%
  full_join(
    district_data %>%
      st_drop_geometry() %>%
      select(NAME_2, population),
    by = c("district" = "NAME_2")
  ) %>%
  mutate(
    access_points = coalesce(access_points, 0),  # Replace NA with 0
    ap_per_school = round(access_points/schools, 2),
    ap_per_1000_people = round((access_points/population) * 1000, 2)  
  )

district_summary <- district_summary %>%
  filter(!is.na(population), !is.na(access_points)) %>%
  arrange(district) 


datatable(province_summary,
          colnames = c("Province", "Number of Schools", "Number of Access Points", "Population", "AP per School", "AP per 1000 people"),
          options = list(pageLength = 20))

datatable(district_summary,
          colnames = c("District", "Number of Schools", "Number of Access Points", "Population", "AP per School", "AP per 1000 people"),
          options = list(pageLength = 20))


#province_summary
#district_summary
```
<br>
We can see from the above tables, that Districts that house cities, are the ones with higher amounts of access points. We see the same behavior with the Provinces, specially with main cities such as Panama, Veraguas and Chiriqui. 
<br>
Most of these studies, however, are based on observations of **conflict events**. In this study, we study the more fundamental variable of a capital's distance from the **population centroid** of the country.
<br>

```{r access-point-district-graph, eval=FALSE, echo=FALSE}
district_summary <- district_summary %>%
  filter(!is.na(population), !is.na(access_points)) %>%
  arrange(district) 


plot_ly(district_summary, 
        x = ~population, 
        y = ~access_points,
        type = 'scatter',
        mode = 'markers',
        marker = list(
          size = 10,
          color = 'rgb(49,130,189)',
          opacity = 0.7,
          line = list(color = 'rgb(27,71,105)', width = 1)
        ),
        text = ~district,
        hovertemplate = paste(
          '<b>District:</b> %{text}<br>',
          '<b>Population:</b> %{x:,}<br>',
          '<b>Access Points:</b> %{y}<br>',
          '<b>Schools:</b> ', district_summary$schools, '<br>',
          '<b>AP per School:</b> ', district_summary$ap_per_school,
          '<extra></extra>'
        )
) %>%
  add_lines(x = ~population,
            y = ~fitted(lm(access_points ~ population, data = district_summary)),
            line = list(color = 'rgb(219,64,82)',
                       width = 2,
                       dash = 'dash'),
            showlegend = TRUE,
            name = 'Trend line') %>%
  layout(
    title = list(
      text = "Access Points vs Population by District",
      font = list(size = 24)
    ),
    xaxis = list(
      title = "Population",
      gridcolor = 'rgb(255,255,255)',
      gridwidth = 2,
      showgrid = TRUE,
      zeroline = FALSE
    ),
    yaxis = list(
      title = "Number of Access Points",
      gridcolor = 'rgb(255,255,255)',
      gridwidth = 2,
      showgrid = TRUE,
      zeroline = FALSE
    ),
    paper_bgcolor = 'rgb(251,251,251)',
    plot_bgcolor = 'rgb(251,251,251)',
    showlegend = TRUE
  )

```
<br>
### Correlations between Population, Schools and Access Points

Below I show 2 plots, where on the left we see the relationship between Access points and Population and on the right, we see the relationship between Access Point-School ratio with the Population.
```{r summary-plots, echo=FALSE}

# Create side-by-side plots
subplot(
  # Left plot: Access Points vs Population
  plot_ly(district_summary, 
          x = ~population, 
          y = ~access_points,
          type = 'scatter',
          mode = 'markers',
          marker = list(
            size = 10,
            color = 'rgb(49,130,189)',
            opacity = 0.7,
            line = list(color = 'rgb(27,71,105)', width = 1)
          ),
          text = ~district,
          hovertemplate = paste(
            '<b>District:</b> %{text}<br>',
            '<b>Population:</b> %{x:,}<br>',
            '<b>Access Points:</b> %{y}<br>',
            '<extra></extra>'
          )
  ) %>%
    add_lines(x = ~population,
              y = ~fitted(lm(access_points ~ population, data = district_summary)),
              line = list(color = 'rgb(219,64,82)',
                         width = 2,
                         dash = 'dash'),
              showlegend = TRUE,
              name = 'Access Points Trend') %>%
    layout(
      title = "Access Points vs Population",
      xaxis = list(
        title = "Population",
        gridcolor = 'rgb(255,255,255)',
        gridwidth = 2,
        showgrid = TRUE,
        zeroline = FALSE
      ),
      yaxis = list(
        title = "Number of Access Points",
        gridcolor = 'rgb(255,255,255)',
        gridwidth = 2,
        showgrid = TRUE,
        zeroline = FALSE
      ),
      paper_bgcolor = 'rgb(251,251,251)',
      plot_bgcolor = 'rgb(251,251,251)'
    ),
  
  # Right plot: Access Points per School
  plot_ly(district_summary, 
          x = ~population, 
          y = ~ap_per_school,
          type = 'scatter',
          mode = 'markers',
          marker = list(
            size = 10,
            color = 'rgb(50,205,50)',
            opacity = 0.7,
            line = list(color = 'rgb(0,100,0)', width = 1)
          ),
          text = ~district,
          hovertemplate = paste(
            '<b>District:</b> %{text}<br>',
            '<b>Population:</b> %{x:,}<br>',
            '<b>Access Points per School:</b> %{y:.2f}<br>',
            '<b>Total Schools:</b> ', district_summary$schools, '<br>',
            '<extra></extra>'
          )
  ) %>%
    add_lines(x = ~population,
              y = ~fitted(lm(ap_per_school ~ population, data = district_summary)),
              line = list(color = 'rgb(255,69,0)',
                         width = 2,
                         dash = 'dash'),
              showlegend = TRUE,
              name = 'AP per School Trend') %>%
    layout(
      title = "Access Points per School vs Population",
      xaxis = list(
        title = "Population",
        gridcolor = 'rgb(255,255,255)',
        gridwidth = 2,
        showgrid = TRUE,
        zeroline = FALSE
      ),
      yaxis = list(
        title = "Access Points per School",
        gridcolor = 'rgb(255,255,255)',
        gridwidth = 2,
        showgrid = TRUE,
        zeroline = FALSE
      ),
      paper_bgcolor = 'rgb(251,251,251)',
      plot_bgcolor = 'rgb(251,251,251)'
    ),
  
  # Subplot layout
  nrows = 1,
  shareX = TRUE,
  titleX = TRUE
)
```

```{r access-point-regression, echo=FALSE}
# Run linear regression
model <- lm(access_points ~ population, data = district_summary)

# View summary of regression results
summary(model)

# For a more detailed analysis, we can also include additional variables
model_extended <- lm(access_points ~ population + schools, data = district_summary)
summary(model_extended)
```

```{r access-points-map, eval=FALSE, echo=FALSE}

# Create the map
ap_map <- leaflet(ap_data) %>%
  # Add base map tiles
  addProviderTiles(providers$CartoDB.Positron) %>%
  # Add access points
  addCircleMarkers(
    radius = 5,
    color = "blue",
    fillColor = "blue",
    fillOpacity = 0.6,
    stroke = TRUE,
    weight = 1,
    popup = ~paste(
      "<strong>Location:</strong>", name, "<br>",
      "<strong>Province:</strong>", province, "<br>",
      "<strong>District:</strong>", district, "<br>",
      "<strong>County:</strong>", county, "<br>",
      "<strong>Type:</strong>", type, "<br>",
      "<strong>Date:</strong>", date
    ),
    # Enable clustering to handle many points
    clusterOptions = markerClusterOptions()
  ) %>%
  # Set the initial view to Panama
  setView(lng = -80.782127, lat = 8.537981, zoom = 7)

ap_map

```
 
```{r district-data-access-points, eval=FALSE, echo=FALSE}
district_data_merged <- district_data %>%
  left_join(district_summary, by = c("NAME_2" = "district"))


breaks <- c(1, 10, 50, 100, 200, max(district_data_merged$access_points))
pal <- colorBin(
  palette = "RdYlGn",
  domain = district_data_merged$access_points,
  bins = breaks,
  reverse = FALSE
)

# Create the map
leaflet(district_data_merged) %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  addPolygons(
    fillColor = ~pal(access_points),
    fillOpacity = 0.7,
    weight = 1,
    color = "#666",
    highlightOptions = highlightOptions(
      weight = 2,
      color = "#666",
      fillOpacity = 0.9,
      bringToFront = TRUE
    ),
    popup = ~paste(
      "<strong>District:</strong>", NAME_2, "<br>",
      "<strong>Province:</strong>", NAME_1, "<br>",
      "<strong>Access Points:</strong>", access_points, "<br>",
      "<strong>Schools:</strong>", schools
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal = pal,
    values = ~access_points,
    title = "Number of Access Points",
    opacity = 0.7,
    labFormat = labelFormat(digits = 0)  # Show integers only
  ) %>%
  setView(lng = -80.782127, lat = 8.537981, zoom = 7)

```

```{r panama-highway, eval=FALSE, echo=FALSE}
panama_bb <- getbb("Panama")
highway <- opq(panama_bb) %>%
  add_osm_feature(key = "name", value = "Carretera Panamericana") %>%
  osmdata_sf()

leaflet() %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  addPolylines(
    data = highway$osm_lines,  # Using the lines from your downloaded data
    color = "red",
    weight = 2,
    opacity = 0.8,
    popup = ~name  # This will show the road name when clicked
  ) %>%
  setView(lng = -80.782127, lat = 8.537981, zoom = 7)

```

```{r schools-map, eval=FALSE, echo=FALSE}


pal <- colorFactor(
  palette = "Set3",
  domain = unique(schools_data$type)
)

leaflet() %>%
  # Add a base map (you can change the provider as we discussed)
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  # Add school points with clustering
  addCircleMarkers(
    data = schools_data,
    radius = 6,
    color = ~pal(type),
    fillOpacity = 1,
    stroke = TRUE,
    weight = 1,
    popup = ~paste(
      "<strong>School:</strong>", name, "<br>",
      "<strong>Type:</strong>", type, "<br>",
      "<strong>Province:</strong>", province, "<br>",
      "<strong>District:</strong>", district, "<br>",
      "<strong>County:</strong>", county
    ),
    clusterOptions = markerClusterOptions()
  ) %>%
  addLegend(
    position = "bottomright",
    pal = pal,
    values = schools_data$type,
    title = "School Type"
  ) %>%
  # Set the initial view to Panama
  setView(lng = -80.782127, lat = 8.537981, zoom = 7)

```

```{r intersection-district-highway, eval=FALSE, echo=FALSE}

districts_with_highway <- st_intersection(district_data, highway$osm_lines)

highway_districts <- unique(districts_with_highway$NAME_2)


leaflet() %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  # Add all districts in light gray
  addPolygons(
    data = district_data,
    fillColor = "lightgray",
    fillOpacity = 0.3,
    weight = 1,
    color = "gray"
  ) %>%
  # Highlight districts with highway in blue
  addPolygons(
    data = district_data[district_data$NAME_2 %in% highway_districts,],
    fillColor = "yellow",
    fillOpacity = 0.3,
    weight = 1,
    color = "blue",
    popup = ~NAME_2
  ) %>%
  # Add the highway in red
  addPolylines(
    data = highway$osm_lines,
    color = "red",
    weight = 2
  ) %>%
  setView(lng = -80.782127, lat = 8.537981, zoom = 7)

```

```{r morans-i, eval=FALSE, echo=FALSE}
district_data_complete <- merge(district_data, 
                              district_summary, 
                              by.x = "NAME_2", 
                              by.y = "district")
# 1. Create a neighbors list based on district boundaries
# Queens case (districts sharing any boundary point)
nb <- poly2nb(district_data_complete, queen = TRUE)

# 2. Create spatial weights
w <- nb2listw(nb, style = "W", zero.policy = TRUE)

# Now calculate Moran's I with zero.policy=TRUE
moran_test <- moran.test(district_data_complete$access_points, w, zero.policy = TRUE)
print(moran_test)

# For visualization
moran.plot(district_data_complete$access_points, w, 
          labels = district_data_complete$NAME_2,
          xlab = "Access Points",
          ylab = "Spatially Lagged Access Points",
          zero.policy = TRUE)

```

```{r morans-i2, eval=FALSE, echo=FALSE}

# Calculate local Moran's I
local_moran <- localmoran(district_data_complete$access_points, w, zero.policy = TRUE)

# Add results to your spatial dataframe
district_data_complete$local_moran <- local_moran[, 1]
district_data_complete$local_moran_p <- local_moran[, 5]

# Map it
leaflet(district_data_complete) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~colorNumeric("RdYlBu", local_moran)(local_moran),
    fillOpacity = 0.7,
    weight = 1,
    color = "white",
    popup = ~paste(
      "<strong>District:</strong>", NAME_2,
      "<br><strong>Local Moran's I:</strong>", round(local_moran, 3),
      "<br><strong>Access Points:</strong>", access_points
    )
  ) %>%
  addLegend(
    position = "bottomright",
    pal = colorNumeric("RdYlBu", local_moran[,1]),
    values = local_moran[,1],
    title = "Local Moran's I"
  )
```

```{r access-points-schools, eval=FALSE, echo=FALSE}

# 1. Access Points and Schools relationship
# Standardize the variables
z_ap <- scale(district_data_complete$access_points)
z_schools <- scale(district_data_complete$schools)

# Calculate Moran's I for Access Points vs Schools
moran_ap_schools <- moran.test(district_data_complete$access_points, 
                              nb2listw(nb, style="W", zero.policy=TRUE), 
                              zero.policy=TRUE)

print("Moran's I for Access Points vs Schools:")
print(moran_ap_schools)

# 2. Access Points and Density relationship
# Standardize density
z_density <- scale(district_data_complete$density)

# Calculate Moran's I for Access Points vs Density
moran_ap_density <- moran.test(district_data_complete$density, 
                              nb2listw(nb, style="W", zero.policy=TRUE), 
                              zero.policy=TRUE)

print("Moran's I for Access Points vs Density:")
print(moran_ap_density)

# Create visualization plots
par(mfrow=c(1,2))  # Set up a 1x2 plotting area

# Plot for Access Points vs Schools
moran.plot(district_data_complete$access_points, 
          nb2listw(nb, style="W", zero.policy=TRUE),
          labels=district_data_complete$NAME_2,
          xlab="Access Points",
          ylab="Spatially Lagged Access Points",
          main="Access Points vs Schools",
          zero.policy=TRUE)

# Plot for Access Points vs Density
moran.plot(district_data_complete$density, 
          nb2listw(nb, style="W", zero.policy=TRUE),
          labels=district_data_complete$NAME_2,
          xlab="Population Density",
          ylab="Spatially Lagged Density",
          main="Access Points vs Density",
          zero.policy=TRUE)
```

```{r density-access-points, eval=FALSE, echo=FALSE}
# Calculate ratio of access points to density
district_data_complete$ap_per_density <- district_data_complete$access_points / district_data_complete$density

# Calculate Moran's I
moran_density <- moran.test(district_data_complete$ap_per_density, w, zero.policy = TRUE)
print("Moran's I for Access Points relative to Population Density:")
print(moran_density)


# Calculate ratio of access points to schools
district_data_complete$ap_per_school <- district_data_complete$access_points / district_data_complete$schools

# Calculate Moran's I
moran_schools <- moran.test(district_data_complete$ap_per_school, w, zero.policy = TRUE)
print("Moran's I for Access Points relative to Schools:")
print(moran_schools)
```

```{r morans-i-plots, eval=FALSE, echo=FALSE}
# Set up to display two Moran plots side by side
par(mfrow=c(1,2))

# Plot for Access Points per Density
moran.plot(district_data_complete$ap_per_density, 
         w,
         labels=district_data_complete$NAME_2,
         xlab="Access Points per Density",
         ylab="Spatially Lagged AP per Density",
         main="Access Points per Density",
         zero.policy=TRUE)

# Plot for Access Points per School
moran.plot(district_data_complete$ap_per_school, 
         w,
         labels=district_data_complete$NAME_2,
         xlab="Access Points per School",
         ylab="Spatially Lagged AP per School",
         main="Access Points per School",
         zero.policy=TRUE)

# Reset plotting parameters
par(mfrow=c(1,1))

# Let's also create choropleth maps to visualize these ratios
# Map for AP per Density
leaflet() %>%
 addProviderTiles(providers$CartoDB.Positron) %>%
 # First map: AP per Density
 addPolygons(
   data = district_data_complete,
   fillColor = ~colorNumeric("viridis", ap_per_density)(ap_per_density),
   fillOpacity = 0.7,
   weight = 1,
   color = "white",
   popup = ~paste(
     "<strong>District:</strong>", NAME_2,
     "<br><strong>AP per Density:</strong>", round(ap_per_density, 4)
   )
 ) 

# Map for AP per School
leaflet() %>%
 addProviderTiles(providers$CartoDB.Positron) %>%
 # Second map: AP per School
 addPolygons(
   data = district_data_complete,
   fillColor = ~colorNumeric("viridis", ap_per_school)(ap_per_school),
   fillOpacity = 0.7,
   weight = 1,
   color = "white",
   popup = ~paste(
     "<strong>District:</strong>", NAME_2,
     "<br><strong>AP per School:</strong>", round(ap_per_school, 4)
   )
 ) 
```

```{r pairwise-intensity, eval=FALSE, echo=FALSE}

# First, transform both datasets to UTM Zone 17N (EPSG:32617)
schools_projected <- st_transform(schools_data, 32617)
ap_projected <- st_transform(ap_data, 32617)
district_projected <- st_transform(district_data, 32617)

# Create the observation window
window <- as.owin(st_union(district_projected))

# Create point pattern objects for both schools and access points
schools_coords <- st_coordinates(schools_projected)
ap_coords <- st_coordinates(ap_projected)

# Create a marked point pattern with both types of points
points_combined <- ppp(
  x = c(schools_coords[,1], ap_coords[,1]),
  y = c(schools_coords[,2], ap_coords[,2]),
  marks = factor(c(rep("school", nrow(schools_coords)),
                  rep("ap", nrow(ap_coords)))),
  window = window
)

# Calculate cross-type pair correlation function
cross_pcf <- pcfcross(points_combined, "school", "ap", correction = "translate")

# Plot the cross-type pair correlation function
plot(cross_pcf, main = "Cross-type PCF: Schools vs Access Points",
     xlab = "Distance (m)", ylab = "g(r)")
abline(h = 1, lty = 2)  # Add reference line at g(r) = 1

# Calculate cross-type K function
cross_K <- Kcross(points_combined, "school", "ap", correction = "border")

# Plot the cross-type K function
plot(cross_K, main = "Cross-type K function: Schools vs Access Points",
     xlab = "Distance (m)")

# Calculate cross-type L function
cross_L <- Lcross(points_combined, "school", "ap", correction = "border")

# Plot the cross-type L function
plot(cross_L, main = "Cross-type L function: Schools vs Access Points",
     xlab = "Distance (m)")


```

```{r buffer-analysis, eval=FALSE, echo=FALSE}

# First project to UTM for accurate buffer creation
highway_projected <- st_transform(highway$osm_lines, 32617)  # UTM 17N
ap_projected <- st_transform(ap_data, 32617)

# Create buffers in UTM
buffer_5km <- st_buffer(highway_projected, 5000)
buffer_10km <- st_buffer(highway_projected, 10000)

# Transform everything back to WGS84 for mapping
highway_wgs84 <- st_transform(highway_projected, 4326)
ap_wgs84 <- st_transform(ap_projected, 4326)
buffer_5km_wgs84 <- st_transform(buffer_5km, 4326)
buffer_10km_wgs84 <- st_transform(buffer_10km, 4326)

# Create the map
leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  # Add the buffers
  addPolygons(
    data = buffer_10km_wgs84,
    fillColor = "yellow",
    fillOpacity = 0.2,
    color = "yellow",
    weight = 1
  ) %>%
  addPolygons(
    data = buffer_5km_wgs84,
    fillColor = "blue",
    fillOpacity = 0.2,
    color = "blue",
    weight = 1
  ) %>%
  # Add the highway
  addPolylines(
    data = highway_wgs84,
    color = "black",
    weight = 2
  ) %>%
  # Add access points
  addCircleMarkers(
    data = ap_wgs84,
    radius = 3,
    color = "red",
    fillOpacity = 0.7
  ) %>%
  # Set the view to Panama
  setView(lng = -80.782127, lat = 8.537981, zoom = 7)

```

```{r highway-distances, eval=FALSE, echo=FALSE}
# Calculate distances from each access point to the nearest part of the highway
distances <- st_distance(ap_projected, highway_projected)
min_distances <- apply(distances, 1, min)  # Get minimum distance for each point

# Convert to kilometers for easier interpretation
min_distances_km <- min_distances/1000

# Basic statistics
distance_stats <- summary(min_distances_km)
print("Summary statistics of distances (in km):")
print(distance_stats)

# Create a histogram of distances
hist(min_distances_km, 
     breaks = 30,
     main = "Distribution of Access Point Distances from Highway",
     xlab = "Distance (km)",
     ylab = "Number of Access Points")

# We can also map this, coloring points by their distance to the highway
# Create a color palette based on distances
pal <- colorNumeric(
  palette = "YlOrRd",  # Yellow to Orange to Red
  domain = min_distances_km
)

# Create map
leaflet() %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  # Add highway
  addPolylines(
    data = highway_wgs84,
    color = "red",
    weight = 2
  ) %>%
  # Add points colored by distance
  addCircleMarkers(
    data = ap_wgs84,
    radius = 3,
    color = ~pal(min_distances_km),
    popup = ~paste("Distance to highway:", round(min_distances_km, 2), "km"),
    fillOpacity = 0.7
  ) %>%
  # Add legend
  
  addLegend(
    position = "bottomright",
    pal = pal,
    values = min_distances_km,
    title = "Distance to Highway (km)"
  ) %>%
  setView(lng = -80.782127, lat = 8.537981, zoom = 7)


```

```{r correlation-schools-ap, eval=FALSE, echo=FALSE}
# Calculate correlation between access points and schools considering spatial weights
ap_schools_correlation <- cor.test(
  district_data_complete$access_points,
  district_data_complete$schools
)

# And with density
ap_density_correlation <- cor.test(
  district_data_complete$access_points,
  district_data_complete$density
)

print("\nSpatial Correlations:")
print("Access Points vs Schools:")
print(ap_schools_correlation)
print("\nAccess Points vs Density:")
print(ap_density_correlation)
```

```{r main-map, eval=FALSE, echo=FALSE}
leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  # Districts with detailed popups
  addPolygons(
    data = district_data_complete,
    weight = 1,
    color = "red",
    fillOpacity = 0.4,
    popup = ~paste(
      "<b>District:</b>", NAME_2,
      "<br><b>Province:</b>", NAME_1,
      "<br><b>Population:</b>", population.x,
      "<br><b>Density:</b>", round(density, 2),
      "<br><b>Number of Schools:</b>", schools,
      "<br><b>Number of Access Points:</b>", access_points,
      "<br><b>AP per School:</b>", round(ap_per_school, 2),
      "<br><b>AP per 1000 People:</b>", round(ap_per_1000_people, 2)
    ),
    group = "Districts"
  ) %>%
  # Schools with detailed popups
  addCircleMarkers(
    data = schools_data,
    radius = 4,
    color = "blue",
    popup = ~paste(
      "<b>School:</b>", name,
      "<br><b>Province:</b>", province,
      "<br><b>District:</b>", district,
      "<br><b>County:</b>", county,
      "<br><b>Type:</b>", type
    ),
    group = "Schools"
  ) %>%
  # Access points with detailed popups
  addCircleMarkers(
    data = ap_data,
    radius = 4,
    color = "green",
    popup = ~paste(
      "<b>Location:</b>", name,
      "<br><b>Province:</b>", province,
      "<br><b>District:</b>", district,
      "<br><b>County:</b>", county,
      "<br><b>Type:</b>", type,
      "<br><b>Date:</b>", date
    ),
    group = "Access Points"
  ) %>%
  # Add layer controls
  addLayersControl(
    overlayGroups = c("Districts", "Schools", "Access Points"),
    options = layersControlOptions(collapsed = FALSE)
  )

```

